#+title: cmacrae's Emacs configuration
#+PROPERTY: header-args:emacs-lisp :tangle yes
#+STARTUP: overview
* About
This is my literate configuration for [[https://www.gnu.org/software/emacs/][Emacs]].
This document includes a collection of configuration snippets to express how I personally like to use Emacs, each accompanied by some reasoning.
I think it's important to include reasoning for each part so I can understand /why/ I use it. Plus the added benefit of others being able to peruse and borrow parts, just as I have from others.

The combination of literacy and functionality is achieved using the amazing [[http://orgmode.org/][org-mode]], with [[http://orgmode.org/worg/org-contrib/babel/][org-babel]].

Throughout this document, you'll notice heavy use of the brilliant [[https://github.com/jwiegley/use-package][use-package]].
For anyone who hasn't tried out =use-package=; I emplore you to do so - it truly makes managing your configuration an absolute joy.

* Early initialization
** Startup
#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'use-package))
#+END_SRC

Time the startup and display the startup time after completed.
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Loaded Emacs in %.03fs"
                     (float-time (time-subtract after-init-time before-init-time)))))
#+END_SRC

Temporarily reduce garbage collection to gain some performance boost during startup.
#+BEGIN_SRC emacs-lisp
(let ((normal-gc-cons-threshold gc-cons-threshold)
      (normal-gc-cons-percentage gc-cons-percentage)
      (normal-file-name-handler-alist file-name-handler-alist)
      (init-gc-cons-threshold most-positive-fixnum)
      (init-gc-cons-percentage 0.6))
  (setq gc-cons-threshold init-gc-cons-threshold
        gc-cons-percentage init-gc-cons-percentage
        file-name-handler-alist nil)
  (add-hook 'after-init-hook
            `(lambda ()
               (setq gc-cons-threshold ,normal-gc-cons-threshold
                     gc-cons-percentage ,normal-gc-cons-percentage
                     file-name-handler-alist ',normal-file-name-handler-alist))))
#+END_SRC

Inhibit startup screen and messages. If you are new to Emacs it is recommended to not
disable the startup screen as it has great content to get you going.
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-echo-area-message t)
(setq inhibit-startup-screen t)
(setq initial-scratch-message nil)
#+END_SRC

Performance tweaks.  Don't load default library and use =fundamental-mode= to reduce amount
of hooks.
#+BEGIN_SRC emacs-lisp
(setq inhibit-default-init t)
(setq initial-major-mode 'fundamental-mode)
#+END_SRC

Disable =package.el= support. Packages are managed via Nix and disabling this gives a slight
performance boost.
#+BEGIN_SRC emacs-lisp
(setq package-enable-at-startup nil)
#+END_SRC

** UI
Don't implicitly resize frames when changing various settings.
#+BEGIN_SRC emacs-lisp
(setq frame-inhibit-implied-resize t)
#+END_SRC

Ignore X resources.
#+BEGIN_SRC emacs-lisp
(advice-add #'x-apply-session-resources :override #'ignore)
#+END_SRC

* Configuration
** General
*** About me
Tell Emacs who's driving
#+BEGIN_SRC emacs-lisp
(setq user-full-name    "Calum MacRae"
      user-mail-address "hi@cmacr.ae")
#+END_SRC

*** Caching
Provide a location where Emacs can store data and cache.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar data-dir
    (if (getenv "XDG_DATA_HOME")
        (concat (getenv "XDG_DATA_HOME") "/emacs/")
      (expand-file-name "~/.local/share/emacs/"))
    "Directory for data.")

  (defvar cache-dir
    (if (getenv "XDG_CACHE_HOME")
        (concat (getenv "XDG_CACHE_HOME") "/emacs/")
      (expand-file-name "~/.cache/emacs/"))
    "Directory for cache.")

  (defvar pictures-dir
    (or (getenv "XDG_PICTURES_DIR")
        (expand-file-name "~/Pictures/"))
    "Directory for pictures."))
#+END_SRC

*** Global =:ensure= for use-package statements
=use-package= has an =:ensure= keyword which dictates whether packages are installed or not.
As most of my =use-package= configurations are for external packages, I set this to always ensure.
Then, in cases where I don't want this to be true, I simply set =:ensure nil=.
For any nested statements, it's necessary to set =:ensure t=.
#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure t)
#+END_SRC

*** Start the server
Start the Emacs server so other clients can connect and use the same session.
This is useful for when you may be oprating Emacs from the GUI usually, but want to use the same session from a TTY/terminal.
Also handy for when you have your ~EDITOR~ set to ~emacsclient~.
#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

*** A few Darwin specific configurations
To make Emacs play a little nicer with window management, enable menu-bar-mode.
Also, set the frame's dimensions based on pixels - this makes Emacs play nicer with tiling
window managers, where no title bar is displayed.
Also, when typing =M-3=, insert an octothorp - I use a British keyboard.
#+BEGIN_SRC emacs-lisp
(cond
 ((string-equal system-type "darwin")
  (setq frame-resize-pixelwise  t)
  (define-key key-translation-map (kbd "M-3") (kbd "#"))
  (menu-bar-mode t)))
#+END_SRC

*** Deactivation of functionality I don't tend to use
- Backup files
- Autosaving
- Start-up message
- Audible bell
- Toolbar, tooltip, scrollbar, blinking cursor
#+BEGIN_SRC emacs-lisp
(setq make-backup-files       nil
      auto-save-default       nil
      inhibit-startup-message t
      frame-title-format      'none
      ring-bell-function      'ignore)
(dolist (mode
         '(tool-bar-mode
           tooltip-mode
           scroll-bar-mode
           blink-cursor-mode))
  (funcall mode 0))
#+END_SRC

*** Comfier frame settings
#+BEGIN_SRC emacs-lisp
(setq default-frame-alist
      (append (list
               '(undecorated-round     . t)
               '(min-height            . 1)
               '(height                . 45)
               '(min-width             . 1)
               '(width                 . 81)
               '(vertical-scroll-bars  . nil)
               '(left-fringe           . 1)
               '(right-fringe          . 1)
               '(tool-bar-lines        . 0)
               '(menu-bar-lines        . 0))))

(modify-all-frames-parameters
 '((right-divider-width . 10)
   (internal-border-width . 20)))

(setq window-divider-default-places 'right-only)
(window-divider-mode 1)
#+END_SRC

*** Set =fill-column=
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
#+END_SRC

*** winner-mode
#+BEGIN_SRC emacs-lisp
(winner-mode 1)
#+END_SRC

*** Globally highlight the current line
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC

*** Discard customizations
Emacs has a comprehensive customization system that allows configuration changes interactively.
Personally, I opt to ensure all the configuration I use for my environment is declarative.
As such, the following configuration sets the ~custom-file~ to be a random temporary file created each time Emacs starts.
This means any customizations made interactively are discarded entirely.
#+BEGIN_SRC emacs-lisp
(setq custom-file (make-temp-file ""))
#+END_SRC

*** Just use 'y' or 'n' instead of 'yes' or 'no'
You'll find =yes-or-no= prompts coming up in Emacs a lot.
I'd much rather just type =y= or =n= than =yes= or =no= every time...
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Confirm quit
This adds a confirmation prompt when quitting Emacs - because I'm only human.
#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC

*** Set the scratch buffer string
Set the scratch buffer's initial contents to include a comment with a timestamp of creation.
Not really all that useful, but cleaner than the default comment, and I like having something there.
#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message (format ";; Scratch buffer - started on %s\n\n" (current-time-string)))
#+END_SRC

*** FlySpell settings
I use =aspell=, so this simply sets [[https://www.emacswiki.org/emacs/FlySpell][Flyspell]] to use it and passes a couple extra arguments
- Configure FlySpell to use aspell
- Set =C-;= to a =nil= binding so it doesn't clash with Treemacs
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :ensure nil
  :after use-package
  :bind
  (:map flyspell-mode-map ("C-;" . nil))
  :init
  (setq ispell-program-name "aspell"
        ispell-extra-args   '("--sug-mode=ultra" "--lang=en_GB")))
#+END_SRC

*** Calendar/Diary
Set the start of the week for the calendar to be Monday.
Sort entries when viewing diary items.
#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1
      diary-file              "~/org/diary")
(add-hook 'diary-list-entries-hook 'diary-sort-entries t)
#+END_SRC

*** IRC
Emacs comes with a great builtin IRC client: ERC.
These are some general settings that're all pretty self explanatory: hide particular activity, autojoin channels for some servers.
For convenience, I've also defined a =erc-conn= function for my usual connection parameters.
#+BEGIN_SRC emacs-lisp
(use-package erc
  :ensure nil
  :custom
  (erc-server "irc.freenode.net" )
  (erc-nick "cmacrae")
  (erc-hide-list '("PART" "QUIT" "JOIN"))
  (erc-autojoin-channels-alist '(("freenode.net"
                                  "#lobsters"
                                  "#nixos"
                                  "#nix-darwin")))
  :config
  (defun cm/erc-conn ()
    (interactive)
    (erc-tls :server "irc.freenode.net" :port 6697 :nick "cmacrae")))
#+END_SRC

*** org-mode
Various pieces of configuration for the mighty org-mode.
#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil
  :custom
  (org-src-fontify-natively            t)
  (org-fontify-quote-and-verse-blocks  t)
  (org-src-tab-acts-natively           t)
  (org-edit-src-content-indentation    0)
  (org-src-preserve-indentation        t))

(use-package org-modern
  :hook
  (org-mode . org-modern-mode)
  (org-agenda-finalize org-modern-agenda)

  :custom
  (org-auto-align-tags                 nil)
  (org-tags-column                     0)
  (org-catch-invisible-edits           'show-and-error)
  (org-special-ctrl-a/e                t)
  (org-insert-heading-respect-content  t)
  (org-hide-emphasis-markers           t)
  (org-pretty-entities                 t)
  (org-ellipsis                        "…")

  (org-agenda-tags-column 0)
  ;; (org-agenda-block-separator ?─)
  (org-agenda-time-grid
  '((daily today require-timed)
    (800 1000 1200 1400 1600 1800 2000)
    " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"))
  (org-agenda-current-time-string
    "⭠ now ─────────────────────────────────────────────────"))

(use-package org-appear
  :hook (org-mode . org-appear-mode))
#+END_SRC

*** Native compilation
I'm using the native compilation features introduced in Emacs 28.
The following setting suppresses automatic display of warning messages.
#+BEGIN_SRC emacs-lisp
(setq comp-async-report-warnings-errors        nil
      native-comp-async-report-warnings-errors nil)
#+END_SRC

** Packages
*** use-package
I use [[https://github.com/nix-community/emacs-overlay][nix-community/emacs-overlay]]'s =emacsWithPackagesFromUsePackage= function to manage my package installation with Nix, but still
control it from within this file. Whilst this statement may seem recursive, it ensures =use-package= is installed before it is ever loaded.
#+BEGIN_SRC emacs-lisp
(use-package use-package)
#+END_SRC

*** Vertico | savehist | orderless | marginalia | Embark | Consult | corfu | cape
This section outlines my preference for Emacs' completion system/interface.
- Vertico: consistent, minimalistic completion UI
- savehist: persists completion history
- orderless: intuitive completion style for candidates based on space separated patterns
- marginalia: annotations for minibuffer candidates
- Embark: act on targets, sort of like a right-click menu
- Consult: practical completion
- corfu: in-buffer completion with pop-ups
- cape: completion-at-point extensions
#+BEGIN_SRC emacs-lisp
(use-package vertico
  :hook (after-init . vertico-mode)
  :custom
  (vertico-resize t))

(use-package vertico-posframe
  :hook
  (vertico-mode . (lambda () (vertico-posframe-mode 1)))
  :custom
  (vertico-posframe-poshandler #'posframe-poshandler-point-frame-center))

(use-package savehist-mode
  :ensure nil
  :hook (after-init . savehist-mode))

(use-package orderless
  :custom
  (completion-styles '(orderless))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles partial-completion)))))

(use-package marginalia
  :hook (after-init . marginalia-mode)
  :custom
  (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil)))

(use-package embark
  :after marginalia
  :bind
  (("C-," . embark-act))

  :config
  (defvar-keymap embark-password-store-actions
    :doc "Keymap for actions for password-store."
    :parent embark-general-map
    "c" #'password-store-copy
    "f" #'password-store-copy-field
    "i" #'password-store-insert
    "I" #'password-store-generate
    "r" #'password-store-rename
    "e" #'password-store-edit
    "k" #'password-store-remove
    "U" #'password-store-url)

  (add-to-list 'embark-keymap-alist '(password-store . embark-password-store-actions))
  (add-to-list 'marginalia-prompt-categories '("Password entry" . password-store))

  :init
  (setq prefix-help-command #'embark-prefix-help-command))

(use-package embark-consult)

(use-package consult
  :bind (("C-s"   . consult-line)
         ("C-c h" . consult-history)
         ("C-c m" . consult-mode-command)
         ("C-c k" . consult-kmacro)

         ("C-x M-:" . consult-complex-command)
         ("C-x b"   . consult-buffer)
         ("C-x 4 b" . consult-buffer-other-window)
         ("C-x 5 b" . consult-buffer-other-frame)
         ("C-x r b" . consult-bookmark)
         ("C-x p b" . consult-project-buffer)

         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)
         ("C-M-#" . consult-register)

         ("M-y" . consult-yank-pop)
         ("<help> a" . consult-apropos)

         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flycheck)
         ("M-g g" . consult-goto-line)
         ("M-g M-g" . consult-goto-line)
         ("M-g o" . consult-outline)
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)

         ("M-s d" . consult-find)
         ("M-s D" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s L" . consult-line-multi)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)

         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)
         ("M-s e" . consult-isearch-history)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)

         :map minibuffer-local-map
         ("M-s" . consult-history)
         ("M-r" . consult-history))

  ;; Enable automatic preview at point in the *Completions* buffer.
  :hook (completion-list-mode . consult-preview-at-point-mode)

  :init

  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)

  ;; Add thin lines, sorting and hide the mode line of the register preview window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  :config

  (consult-customize
   consult-theme
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-recent-file
   consult--source-project-recent-file
   :preview-key '(:debounce 0.2 any))

  (setq consult-narrow-key "<") ;; (kbd "C-+")

  (autoload 'projectile-project-root "projectile")
  (setq consult-project-function (lambda (_) (projectile-project-root))))

(use-package corfu
  :custom
  (corfu-auto t)
  :hook
  (after-init . global-corfu-mode))

(use-package cape
  :after corfu
  :config
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file))
#+END_SRC

*** Theme | Modeline
**** theme
#+BEGIN_SRC emacs-lisp
(use-package nano-theme
  :custom
  (nano-window-divider-show t)
  :config
  (load-theme 'nano-light t))
#+END_SRC

**** mood-line
#+BEGIN_SRC emacs-lisp
(use-package nano-modeline
  :demand t
  :hook
  (prog-mode            . nano-modeline-prog-mode)
  (text-mode            . nano-modeline-text-mode)
  (org-mode             . nano-modeline-org-mode)
  (pdf-view-mode        . nano-modeline-pdf-mode)
  (mu4e-headers-mode    . nano-modeline-mu4e-headers-mode)
  (mu4e-view-mode       . nano-modeline-mu4e-message-mode)
  (elfeed-show-mode     . nano-modeline-elfeed-entry-mode)
  (elfeed-search-mode   . nano-modeline-elfeed-search-mode)
  (vterm-mode           . nano-modeline-term-mode)
  (xwidget-webkit-mode  . nano-modeline-xwidget-mode)
  (messages-buffer-mode . nano-modeline-message-mode)
  (org-capture-mode     . nano-modeline-org-capture-mode)
  (org-agenda-mode      . nano-modeline-org-agenda-mode)

  :config
  (setq-default mode-line-format nil))
#+END_SRC

*** tectum
#+BEGIN_SRC emacs-lisp
;; (use-package tectum
;;   :ensure nil
;;   :load-path "~/src/github.com/cmacrae/tectum"
;;   :hook
;;   (org-mode . tectum-mode)
;;   :custom
;;   (tectum-header-prefix-display-function 'tectum-element-just-mode-icon)
;;   :config
;;   (defun tectum-element-just-mode-icon ()
;;     "Just the mode icon."
    
;;     (concat
;;      "   "
;;      (tectum-element-mode-icon))))

;; (use-package svg-lib)
;; (use-package nano-dialog)
;; (use-package define-word)
;; (use-package olivetti)
#+END_SRC

*** solaire-mode | dimmer
The following expression adds a little flair to focussed buffers and those visiting files. I have it activate upon visiting files and after switching perspectives.
#+BEGIN_SRC emacs-lisp
(use-package solaire-mode
  :init
  (advice-add #'persp-load-state-from-file :after #'solaire-mode-restore-persp-mode-buffers)
  :hook
  (after-change-major-mode . turn-on-solaire-mode))

(use-package dimmer
  :hook (after-init . dimmer-mode)
  :config
  (dimmer-configure-hydra)
  (dimmer-configure-magit)
  (dimmer-configure-org))
#+END_SRC

*** centaur-tabs
Fancy buffer tabs
- Disable for a few modes
- Set the header face to fit better
- Set tab grouping to work with Projectile
- Bottom bar style tab indicator
- Turn on icons
- Set the cycle scope to current project tabs
- Bind "N"/"E" in normal Evil state to move forward/backward
#+BEGIN_SRC emacs-lisp
;; (use-package centaur-tabs
;;   :after evil-colemak-basics
;;   :hook
;;   (evil-colemak-basics-mode . centaur-tabs-mode)
;;   (vterm-mode               . centaur-tabs-local-mode)
;;   (calendar-mode            . centaur-tabs-local-mode)
;;   (org-agenda-mode          . centaur-tabs-local-mode)
;;   (helpful                  . centaur-tabs-local-mode)
;;   :config
;;   (centaur-tabs-headline-match)
;;   (centaur-tabs-group-by-projectile-project)
;;   ;; (define-key evil-normal-state-map (kbd "N") 'centaur-tabs-backward)
;;   ;; (define-key evil-normal-state-map (kbd "N") 'centaur-tabs-backward)
;;   ;; (define-key evil-colemak-basics-map (kbd "N") 'centaur-tabs-backward)
;;   ;; (define-key evil-colemak-basics-map (kbd "N") 'centaur-tabs-backward)
;;   :custom
;;   (centaur-tabs-style "bar")
;;   (centaur-tabs-set-bar 'left)
;;   (centaur-tabs-set-close-button nil)
;;   (centaur-tabs-show-new-tab-button nil)
;;   (centaur-tabs-set-icons t)
;;   (centaur-tabs-cycle-scope 'tabs))
;;   ;; :bind
;;   ;; (:map evil-colemak-basics-keymap
;;   ;;    ("N" . centaur-tabs-backward)
;;   ;;    ("E" . centaur-tabs-forward)
;;   ;;  :map evil-normal-state-map
;;   ;;    ("N" . centaur-tabs-backward)
;;   ;;    ("E" . centaur-tabs-forward)))
#+END_SRC

*** which-key
Helpful reminders for which keybindings are available
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :hook (after-init . which-key-mode))
#+END_SRC

*** Evil
Vim emulation in Emacs. Because: yes, you can have the best of both worlds!
Below you'll find various extensions to my Evil layer that generally improve the quality of life.
#+BEGIN_SRC emacs-lisp
(use-package evil
  :init
  (setq evil-want-C-u-scroll t)
  (setq evil-want-keybinding nil)
  :hook (after-init . evil-mode)
  :custom (evil-respect-visual-line-mode t))
#+END_SRC

**** Evil Collection
A collection of Evil bindings, for the parts of Emacs that Evil does not cover properly by default
#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :after evil
  :init
  (setq evil-collection-outline-bind-tab-p t)
  :hook (evil-mode . evil-collection-init))
#+END_SRC

**** Evil Colemak Basics
For using the Colemak layout with Evil bindings.
#+BEGIN_SRC emacs-lisp
(use-package evil-colemak-basics
  :after (evil evil-snipe evil-collection)
  :custom
  (evil-colemak-basics-layout-mod 'mod-dh)
  (evil-colemak-basics-char-jump-commands 'evil-snipe)
  :config
  (global-evil-colemak-basics-mode))
#+END_SRC

**** EasyMotion
Buffer traversal made easy! Emulates easymotion.vim
#+BEGIN_SRC emacs-lisp
(use-package evil-easymotion
  :after evil
  :config
  (evilem-default-keybindings "SPC"))
#+END_SRC

**** Goggles
Visual hints when performing Evil operations (dd, yy, cw, p, etc.)
#+BEGIN_SRC emacs-lisp
(use-package evil-goggles
  :after evil
  :hook (evil-mode . evil-goggles-mode)
  :config (evil-goggles-use-diff-faces))
#+END_SRC

**** Lion
Align operators (gl & gL), emulating lion.vim
#+BEGIN_SRC emacs-lisp
(use-package evil-lion
  :after evil
  :hook (evil-mode . evil-lion-mode))
#+END_SRC

**** Commentary
Easily comment lines/blocks. Emulates commentary.vim
#+BEGIN_SRC emacs-lisp
(use-package evil-commentary
  :after evil
  :hook (evil-mode . evil-commentary-mode))
#+END_SRC

**** Snipe
2-char searching with f, F, t, T operators. Like seek.vim/sneak.vim
#+BEGIN_SRC emacs-lisp
(use-package evil-snipe
  :after evil
  :hook
  (evil-mode . evil-snipe-mode)
  (evil-snipe-mode . evil-snipe-override-mode))
#+END_SRC

**** multiedit
#+BEGIN_SRC emacs-lisp
(use-package evil-multiedit
  :after evil
  :hook (evil-mode . evil-multiedit-default-keybinds)
  :config
  (evil-ex-define-cmd "ie[dit]" 'evil-multiedit-ex-match))
#+END_SRC

**** surround
#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :after evil
  :hook (evil-mode . global-evil-surround-mode))
#+END_SRC

*** Projectile
Project management based on version control repositories.
Absolutely essential package for me. This makes hopping around and between various projects really easy.
Not only that, but it allows project-wide actions. Like killing all buffers for a project, performing a project-wide find-and-replace, or a grep, etc.

Some configuration I use:
- Further integration of Counsel with Projectile than what's provided natively
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :hook
  (after-init . projectile-global-mode)
  :custom
  (projectile-completion-system 'auto)
  (projectile-switch-project-action 'treemacs-add-and-display-current-project-exclusively)
  :bind
  (:map projectile-mode-map
          ("C-x p p" . projectile-persp-switch-project)))
#+END_SRC

*** perspective
Workspaces! Indespensible if you work on a lot of projects. Perspective is like workspaces (virtual desktops) for Emacs. It’s a means of namespacing a group of tangible buffers. When combined with Projectile, this becomes a really nice combination as projects then seemlessly translate to workspaces.

#+BEGIN_SRC emacs-lisp
(use-package perspective
  :hook (after-init . persp-mode)
  :custom
  (persp-show-modestring nil)
  (persp-suppress-no-prefix-key-warning t)
  :config

  (use-package persp-projectile
    :ensure t
    :after perspective))
#+END_SRC

*** Treemacs
Sidebar filebrowser, very handy.

#+BEGIN_SRC emacs-lisp
(use-package treemacs
  :init
  (with-eval-after-load 'winum
    (define-key winum-keymap (kbd "C-;") #'treemacs-select-window))
  :config
  (progn
    (setq treemacs-collapse-dirs                   1
          treemacs-deferred-git-apply-delay        0.5
          treemacs-directory-name-transformer      #'identity
          treemacs-display-in-side-window          t
          treemacs-eldoc-display                   'simple
          treemacs-file-event-delay                2000
          treemacs-file-extension-regex            treemacs-last-period-regex-value
          treemacs-file-follow-delay               0.2
          treemacs-file-name-transformer           #'identity
          treemacs-follow-after-init               t
          treemacs-expand-after-init               t
          treemacs-find-workspace-method           'find-for-file-or-pick-first
          treemacs-git-command-pipe                ""
          treemacs-goto-tag-strategy               'refetch-index
          treemacs-header-scroll-indicators        '(nil . "^^^^^^")
          treemacs-hide-dot-git-directory          t
          treemacs-indentation                     2
          treemacs-indentation-string              " "
          treemacs-is-never-other-window           nil
          treemacs-max-git-entries                 5000
          treemacs-missing-project-action          'ask
          treemacs-move-forward-on-expand          nil
          treemacs-no-png-images                   nil
          treemacs-no-delete-other-windows         t
          treemacs-project-follow-cleanup          nil
          treemacs-persist-file                    (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
          treemacs-position                        'left
          treemacs-read-string-input               'from-child-frame
          treemacs-recenter-distance               0.1
          treemacs-recenter-after-file-follow      nil
          treemacs-recenter-after-tag-follow       nil
          treemacs-recenter-after-project-jump     'always
          treemacs-recenter-after-project-expand   'on-distance
          treemacs-litter-directories              '("/result")
          treemacs-project-follow-into-home        nil
          treemacs-show-cursor                     nil
          treemacs-show-hidden-files               nil
          treemacs-silent-filewatch                nil
          treemacs-silent-refresh                  nil
          treemacs-sorting                         'alphabetic-asc
          treemacs-select-when-already-in-treemacs 'move-back
          treemacs-space-between-root-nodes        t
          treemacs-tag-follow-cleanup              t
          treemacs-tag-follow-delay                1.5
          treemacs-text-scale                      nil
          treemacs-user-mode-line-format           'none
          treemacs-user-header-line-format         nil
          treemacs-wide-toggle-width               70
          treemacs-width                           35
          treemacs-width-increment                 1
          treemacs-width-is-initially-locked       t
          treemacs-workspace-switch-cleanup        nil)

    (treemacs-follow-mode t)
    (treemacs-filewatch-mode t)
    (treemacs-fringe-indicator-mode 'always)
    (when treemacs-python-executable
      (treemacs-git-commit-diff-mode t))

    (pcase (cons (not (null (executable-find "git")))
                 (not (null treemacs-python-executable)))
      (`(t . t)
       (treemacs-git-mode 'deferred))
      (`(t . _)
       (treemacs-git-mode 'simple)))

    (treemacs-hide-gitignored-files-mode nil))
  :bind
  (:map global-map
        ("C-;"       . treemacs-select-window)
        ("C-x t 1"   . treemacs-delete-other-windows)
        ("C-x t t"   . treemacs)
        ("C-x t d"   . treemacs-select-directory)
        ("C-x t B"   . treemacs-bookmark)
        ("C-x t C-t" . treemacs-find-file)
        ("C-x t M-t" . treemacs-find-tag)))

(use-package treemacs-evil
  :after (treemacs evil))

(use-package treemacs-projectile
  :after (treemacs projectile))

(use-package treemacs-icons-dired
  :hook (dired-mode . treemacs-icons-dired-enable-once)
  :ensure t)

(use-package treemacs-magit
  :after (treemacs magit))

(use-package treemacs-all-the-icons
  :after
  (treemacs all-the-icons)
  :config
  (treemacs-load-theme "all-the-icons"))

(use-package treemacs-perspective ;;treemacs-perspective if you use perspective.el vs. persp-mode
  :after (treemacs perspective) ;;or perspective vs. persp-mode
  :config (treemacs-set-scope-type 'Perspectives))

;; (use-package treemacs-tab-bar ;;treemacs-tab-bar if you use tab-bar-mode
;;   :after (treemacs)
;;   :ensure t
;;   :config (treemacs-set-scope-type 'Tabs))
#+END_SRC

*** Magit
The one true Git porcelain!
Truly a joy to use - it surfaces the power of Git in such a fluent manner.
Anyone using Git and Emacs *needs* Magit in their life!

Here, I'm ensuring Emacs knows to use the gpg-agent's SSH socket.
I'm also extending Magit's functionality to work with  popular "git forges". Specific configuration for this is to:
- Only show open topics (issues/PRs)
- Only show authored PRs
- Upon PR creation, yank the title & URL

I'm also using a handy package to layer on TODO notes in the Magit status buffer.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind ("C-c m" . magit-status)
  :config
  (cond
   ((string-equal system-type "linux")
    (setenv "SSH_AUTH_SOCK" "/run/user/1000/gnupg/S.gpg-agent.ssh"))))

(use-package forge
  :after magit
  :custom
  (forge-topic-list-limit '(30 . -1))
  :config
  (defun cm/forge-post-submit-callback-browse-pr (value _headers _status _req)
    (when t
      (when-let ((url (alist-get 'html_url value)))
        (browse-url url))))

  (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-authored-pullreqs 'forge-insert-pullreqs 'replace)
  (add-hook 'forge-post-submit-callback-hook 'cm/forge-post-submit-callback-browse-pr))


(use-package magit-todos
  :after magit
  :config (magit-todos-mode 1))
#+END_SRC

*** git-link
Quickly yank a Git forge link for the current file/line.
Useful for when collaborating and you want to share what you're looking at.
#+BEGIN_SRC emacs-lisp
(use-package git-link
  :bind
  ("C-c g l" . git-link))
#+END_SRC

*** vterm
Fully-fledged terminal emulator based on [[https://github.com/neovim/libvterm][libvterm]]!
I manage the module and elisp as a Nix overlay in [[https://github.com/cmacrae/config][my system configuration]], so no need to install it.
Set it up to play nice with Evil.

#+BEGIN_SRC emacs-lisp
(use-package vterm
  :after evil
  :hook
  (vterm-mode . (lambda ()
                  (setq-local evil-insert-state-cursor 'hbar)
                  (evil-insert-state)))
  :config
  (define-key vterm-mode-map [return]                      #'vterm-send-return)
  (setq vterm-keymap-exceptions nil)
  (evil-define-key 'insert vterm-mode-map (kbd "C-e")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-f")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-a")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-v")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-b")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-w")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-u")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-d")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-n")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-m")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-p")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-j")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-k")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-r")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-t")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-g")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-c")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-SPC")    #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-y")      #'vterm--self-insert)
  (evil-define-key 'normal vterm-mode-map (kbd "C-d")      #'vterm--self-insert)
  (evil-define-key 'normal vterm-mode-map (kbd "p")        #'vterm-yank)
  (evil-define-key 'normal vterm-mode-map (kbd "i")        #'evil-insert-resume)
  (evil-define-key 'normal vterm-mode-map (kbd "o")        #'evil-insert-resume)
  (evil-define-key 'normal vterm-mode-map (kbd "<return>") #'evil-insert-resume)

  (setq vterm-ignore-blink-cursor t)

  (use-package multi-vterm
    :ensure t
    :bind
    ("C-x p t" . multi-vterm-project)))
#+END_SRC

*** Flycheck
Have Flycheck turned on for everything - checking stuff is always good!
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :after envrc
  :hook (after-init . global-flycheck-mode))
#+END_SRC

*** hydra
Great package to tie tangible actions together into convenient keybinding landscapes.
Here, you'll find some "general" hydras - other hydras that are centric around packages will be found with that package's configuration.

General hydras:
- Zoom: increase/decrease current buffer text size
- Transpose: transpose various constructs of text
- Perspective: common bindings useful for perspective

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :bind
  ("C-x z" . hydra-zoom/body)
  ("C-x T" . hydra-transpose/body)
  ("C-x x" . hydra-persp/body)

  :config

  (defhydra hydra-zoom ()
    "Zoom"
    ("i" text-scale-increase "In")
    ("o" text-scale-decrease "Out")
    ("q" nil "Quit" :color blue))

  (defhydra hydra-transpose (:color red)
    "Transpose"
    ("c" transpose-chars "Characters")
    ("w" transpose-words "Words")
    ("l" transpose-lines "Lines")
    ("s" transpose-sentences "Sentences")
    ("p" transpose-paragraphs "Paragraphs")
    ("q" nil "Quit" :color blue))

  (defhydra hydra-persp (:columns 4 :color blue)
    "Perspective"
    ("a" persp-add-buffer "Add Buffer")
    ("i" persp-import "Import")
    ("c" persp-kill "Close")
    ("n" persp-next "Next")
    ("p" persp-prev "Prev")
    ("k" persp-remove-buffer "Kill Buffer")
    ("r" persp-rename "Rename")
    ("A" persp-set-buffer "Set Buffer")
    ("s" persp-switch "Switch")
    ("C-x" persp-switch-last "Switch Last")
    ("b" persp-switch-to-buffer "Switch to Buffer")
    ("P" projectile-persp-switch-project "Switch Project")
    ("q" nil "Quit")))
#+END_SRC

*** ace-window
Jump around Emacs windows & frames using character prefixes.
I use this constantly - it even works across multiple frames.
Also added a hydra borrowed from [[https://oremacs.com/2015/01/29/more-hydra-goodness/][here]] for some really convenient movement/manipulation!
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :bind ("M-o" . hydra-window/body)
  :custom
  (aw-dispatch-always t)
  (aw-keys '(?a ?r ?s ?t ?g ?m ?n ?e ?i ?o))
  :config
  (defhydra hydra-window (:color blue)
    "window"
    ("m" windmove-left "left")
    ("n" windmove-down "down")
    ("e" windmove-up "up")
    ("i" windmove-right "right")
    ("a" ace-window "ace")
    ("s" (lambda () (interactive) (ace-window 4)) "swap")
    ("d" (lambda () (interactive) (ace-window 16)) "delete")
    ("q" nil "Quit")))
  ;; (defhydra hydra-window (:color blue)
  ;;   "window"
  ;;   ("h" windmove-left "left")
  ;;   ("j" windmove-down "down")
  ;;   ("k" windmove-up "up")
  ;;   ("l" windmove-right "right")
  ;;   ("a" ace-window "ace")
  ;;   ("s" (lambda () (interactive) (ace-window 4)) "swap")
  ;;   ("d" (lambda () (interactive) (ace-window 16)) "delete")
  ;;   ("q" nil "Quit")))
#+END_SRC

*** password-store
I use [[https://www.passwordstore.org/][pass]] as my password manager, which comes with its own functions for Emacs
#+BEGIN_SRC emacs-lisp
(use-package password-store
  :demand t
  :bind
  ("C-x M-p" . password-store-copy)
  :custom
  (auth-sources '(password-store)))
#+END_SRC

*** Smartparens
Brilliant automatic balancing of pairs. Makes for a really nice experience when typing in any language - programming or not.
Just check out some of the gifs in the project's README.
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :hook (after-init . smartparens-global-mode)
  :config
  (use-package evil-smartparens
    :ensure t
    :hook
    (smartparens-global-mode . evil-smartparens-mode)))
#+END_SRC

*** all-the-icons
This places little glyphs around to better convey some things where text may be a bit cluttered. That, and it makes things look nice! We’re visual creatures, after-all.
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :config
  (use-package all-the-icons-dired
    :ensure t
    :hook
    (dired-mode . all-the-icons-dired-mode)))
#+END_SRC

*** rainbow-delimeters
Colourize delimiters differently based on their depth. Really helps you not get burried when you’re in deep.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook
  (prog-mode . rainbow-delimiters-mode)
  (yaml-mode . rainbow-delimiters-mode))
#+END_SRC

*** corral
Quickly surround text with delimiters.
#+BEGIN_SRC emacs-lisp
(use-package corral
  :bind
  ("M-9" . corral-parentheses-backward)
  ("M-0" . corral-parentheses-forward)
  ("M-[" . corral-brackets-backward)
  ("M-]" . corral-brackets-forward)
  ("M-{" . corral-braces-backward)
  ("M-}" . corral-braces-forward)
  ("M-'" . corral-single-quotes-backward)
  ("M-\"" . corral-double-quotes-backward))
#+END_SRC

*** expand-region
Select regions by semantic units. Really handy for selecting regions of data - just repeat keypress to expand selection further.
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind ("C-=" . er/expand-region))
#+END_SRC

*** hl-todo
NOTE/TODO/FIXME highlighting in comments
#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :hook
  (after-init . global-hl-todo-mode)
  (yaml-mode . hl-todo-mode))
#+END_SRC

*** centered-window-mode
Keep buffer text centered. I've added a hook to ensure my preferred =internal-border-width= setting is retained.
#+BEGIN_SRC emacs-lisp
(use-package centered-window
  :commands centered-window-mode
  :hook
  (centered-window-mode . (lambda ()
                            (set-frame-parameter nil 'internal-border-width 10))))
#+END_SRC

*** Kubernetes
#+BEGIN_SRC emacs-lisp
(use-package kubernetes
  :commands kubernetes-overview
  :config
  (use-package kubernetes-evil
    :ensure t
    :after kubernetes))
#+END_SRC

*** mini-frame
Place a minibuffer on top of the current frame
#+BEGIN_SRC emacs-lisp
;; (use-package mini-frame
;;   :hook (after-init . mini-frame-mode)
;;   :custom
;;   (mini-frame-resize t)
;;   (mini-frame-show-parameters '((top . 10)
;;                                 (width . 0.7)
;;                                 (left . 0.5))))
#+END_SRC

*** envrc | inheritenv
Support for ~direnv~, which operates buffer-locally.
#+BEGIN_SRC emacs-lisp
(use-package envrc
  :hook (after-init . envrc-global-mode))

(use-package inheritenv :demand t)
#+END_SRC

*** gptel
LLMs in Emacs, what a time to be alive
#+BEGIN_SRC emacs-lisp
(use-package gptel
  :hook
  (gptel-mode . visual-line-mode)
  (gptel-post-stream . gptel-auto-scroll)
  (gptel-post-response-functions . gptel-end-of-response)
  :custom (gptel-default-mode #'org-mode))
#+END_SRC

** Languages
Configuration for working with various languages
#+BEGIN_SRC emacs-lisp
(use-package nix-mode)
(use-package go-mode)
(use-package json-mode)
(use-package yaml-mode)
(use-package toml-mode)
(use-package rego-mode)
(use-package swift-mode)
(use-package python-mode)
(use-package just-mode)

(use-package jenkinsfile-mode
  :mode ("\\Jenkinsfile\\'" "\\.pipeline\\'"))

(use-package rustic
  :config
  (setq rustic-lsp-client 'eglot)
  (setq rustic-format-trigger 'on-save)
  (setq rustic-format-on-save-method 'eglot-format-buffer))

(use-package markdown-mode
  :mode "\\.md\\'"
  :hook
  (markdown-mode . flyspell-mode))

(use-package terraform-mode)

(use-package dockerfile-mode
  :mode "\\Dockerfile\\'")

(use-package web-mode
  :mode "\\.html"
  :custom
  (web-mode-engines-alist '(("go" . "\\.gotmpl\\'"))))
#+END_SRC

*** Language Server Protocol integration
#+BEGIN_SRC emacs-lisp
(use-package eglot
  :ensure nil
  :after inheritenv
  :hook
  (prog-mode . eglot-ensure)
  (prog-mode . (lambda () (add-hook 'before-save-hook 'eglot-format nil t)))
  :config
  (with-eval-after-load 'eglot
    (dolist (mode '((nix-mode       . ("nil" :initializationOptions
                                             (:formatting (:command [ "nixpkgs-fmt" ]))))
                    (python-mode    . ("pylsp"))
                    (terraform-mode . ("terraform-lsp"))
                    (rust-mode      . ("rust-analyzer"))))
      (add-to-list 'eglot-server-programs mode))))
                  #+END_SRC

** Custom functions
Useful functions gathered that don’t quite require an entire package.

*** Sensible beginning of line
Taken from [[http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][here]], I use this to replace move-beginning-of-line (C-a). It will take your point back to the first column of the line you’re on,
as per the indentation. A second press will then take your point back to the very beginning of the line.
Pressing again will take you back to the indented column.
#+BEGIN_SRC emacs-lisp
(defun cm/sensible-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

      Move point to the first non-whitespace character on this line.
      If point is already there, move to the beginning of the line.
      Effectively toggle between the first non-whitespace character and
      the beginning of the line.

      If ARG is not nil or 1, move forward ARG - 1 lines first.  If
      point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(global-set-key (kbd "C-a") 'cm/sensible-move-beginning-of-line)
#+END_SRC
